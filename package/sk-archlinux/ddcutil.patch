diff --git a/include/modules/ddcutil.hpp b/include/modules/ddcutil.hpp
new file mode 100644
index 00000000..99edcf09
--- /dev/null
+++ b/include/modules/ddcutil.hpp
@@ -0,0 +1,37 @@
+#pragma once
+
+#include <map>
+#include <string>
+
+#include "ALabel.hpp"
+#include "bar.hpp"
+#include "util/sleeper_thread.hpp"
+
+namespace waybar::modules {
+
+class DdcUtil : public ALabel {
+ public:
+  DdcUtil(const std::string&, const waybar::Bar&, const Json::Value&);
+  ~DdcUtil();
+  void update();
+
+ private:
+  void worker();
+  bool handleToggle(GdkEventButton* const& e);
+  std::string input_source_name(uint8_t input) const;
+  uint8_t get_input_source() const;
+  uint8_t set_input_source(uint8_t target_input) const;
+  std::string source_to_class(const uint8_t input) const;
+
+  const Bar&            bar_;
+  const int             i2c_bus_;
+  const std::map<uint8_t, std::string> input_name_;
+  const uint8_t        primary_input_;
+  const uint8_t        secondary_input_;
+  uint8_t              curr_input_;
+  std::string           status_;
+  util::SleeperThread   thread_;
+  std::mutex            ddc_mutex_;
+};
+
+}  // namespace waybar::modules
diff --git a/meson.build b/meson.build
index 738f98b3..1a391630 100644
--- a/meson.build
+++ b/meson.build
@@ -93,6 +93,7 @@ libmpdclient = dependency('libmpdclient', required: get_option('mpd'))
 xkbregistry = dependency('xkbregistry')
 libjack = dependency('jack', required: get_option('jack'))
 libwireplumber = dependency('wireplumber-0.5', required: get_option('wireplumber'))
+ddcutil = dependency('ddcutil', version : '>=1.1.0')
 
 libsndio = compiler.find_library('sndio', required: get_option('sndio'))
 if libsndio.found()
@@ -163,6 +164,7 @@ src_files = files(
     'src/AIconLabel.cpp',
     'src/AAppIconLabel.cpp',
     'src/modules/custom.cpp',
+    'src/modules/ddcutil.cpp',
     'src/modules/disk.cpp',
     'src/modules/gammastep.cpp',
     'src/modules/idle_inhibitor.cpp',
@@ -535,8 +537,9 @@ executable(
         gtk_layer_shell,
         libsndio,
         tz_dep,
-		xkbregistry,
-        cava
+        xkbregistry,
+        cava,
+        ddcutil
     ],
     include_directories: inc_dirs,
     install: true,
diff --git a/resources/config.jsonc b/resources/config.jsonc
index 92186c332..1294c2c4 100644
--- a/resources/config.jsonc
+++ b/resources/config.jsonc
@@ -19,6 +19,7 @@
         "mpd",
         "idle_inhibitor",
         "gammastep",
+        "ddcutil",
         "pulseaudio",
         "network",
         "power-profiles-daemon",
@@ -111,6 +112,19 @@
         },
         "interval": 5
     },
+    "ddcutil": {
+        "format": "{status} üñ•Ô∏è",
+        "bus": 8,
+        "interval": 5,
+        "input-names": {
+             "0x0F": "DP2",
+             "0x10": "DP1",
+             "0x11": "HDMI1",
+             "0x12": "HDMI2",
+        },
+        "primary-input": "DP1",
+        "secondary-input": "DP2",
+    },
     "tray": {
         // "icon-size": 21,
         "spacing": 10,
diff --git a/resources/style.css b/resources/style.css
index 3fc6027e..77046ed3 100644
--- a/resources/style.css
+++ b/resources/style.css
@@ -94,6 +94,7 @@ button:hover {
 #scratchpad,
 #power-profiles-daemon,
 #gammastep,
+#ddcutil,
 #mpd {
     padding: 0 10px;
     color: #ffffff;
@@ -267,6 +268,26 @@ label:focus {
     color: #ffffff;
 }
 
+#ddcutil {
+    background-color: #00b093;
+    color: #740864;
+}
+
+#ddcutil.primary {
+    color: #2a5c45;
+    background-color: #51a37a;
+}
+
+#ddcutil.secondary {
+    color: #2a5c45;
+    background-color: #66cc99;
+}
+
+#ddcutil.error {
+    color: #2a5c45;
+    background-color: #f53c3c;
+}
+
 #mpd {
     background-color: #66cc99;
     color: #2a5c45;
diff --git a/src/factory.cpp b/src/factory.cpp
index b691490f..dffb704e 100644
--- a/src/factory.cpp
+++ b/src/factory.cpp
@@ -52,6 +52,7 @@
 #endif
 #include "modules/idle_inhibitor.hpp"
 #include "modules/gammastep.hpp"
+#include "modules/ddcutil.hpp"
 #if defined(HAVE_MEMORY_LINUX) || defined(HAVE_MEMORY_BSD)
 #include "modules/memory.hpp"
 #endif
@@ -229,6 +230,9 @@ waybar::AModule* waybar::Factory::makeModule(const std::string& name,
     if (ref == "gammastep") {
       return new waybar::modules::Gammastep(id, bar_, config_[name]);
     }
+    if (ref == "ddcutil") {
+      return new waybar::modules::DdcUtil(id, bar_, config_[name]);
+    }
 #if defined(HAVE_MEMORY_LINUX) || defined(HAVE_MEMORY_BSD)
     if (ref == "memory") {
       return new waybar::modules::Memory(id, config_[name]);
diff --git a/src/modules/ddcutil.cpp b/src/modules/ddcutil.cpp
new file mode 100644
index 00000000..b3911bfd
--- /dev/null
+++ b/src/modules/ddcutil.cpp
@@ -0,0 +1,220 @@
+#include <mutex>
+#include <fmt/format.h>
+#include "modules/ddcutil.hpp"
+#include <ddcutil_c_api.h>
+#include <ddcutil_status_codes.h>
+#include <spdlog/spdlog.h>
+
+namespace {
+
+std::map<uint8_t, std::string> parse_input_names(const Json::Value& config) {
+  std::map<uint8_t, std::string> result;
+  if (config["input-names"].isObject()) {
+    const Json::Value& input_names = config["input-names"];
+    // Cannot do range-based iteration since no way to access value's key there.
+    for (auto it = input_names.begin(); it != input_names.end(); ++it) {
+      if (!it.key().isString()) throw std::runtime_error("Input names key should be a string");
+      if (!it->isString()) throw std::runtime_error("Input names value should be a string");
+      const std::string key = it.key().asString();
+      const std::string value = it->asString();
+      const unsigned long key_ul = std::stoul(key, nullptr, 0);
+      if (key_ul > UINT8_MAX) throw std::runtime_error("Input names key out of range");
+      result.emplace(static_cast<uint8_t>(key_ul), value);
+    }
+  }
+  return result;
+}
+
+uint8_t lookup_input(const Json::Value& value, const std::map<uint8_t, std::string>& input_names) {
+  if (!value.isString()) throw std::runtime_error("Input is not a string");
+  const std::string value_str = value.asString();
+  for (const auto& [k, v] : input_names) {
+    if (v == value_str) return k;
+  }
+  throw std::runtime_error("Input name not found");
+}
+
+struct DisplayIdDeleter {
+  void operator()(DDCA_Display_Identifier* display_id) {
+    const DDCA_Status rc = ddca_free_display_identifier(*display_id);
+    if (rc != 0) {
+      spdlog::error("ddcutil: Failed to free display id: {}, {}", ddca_rc_name(rc), ddca_rc_desc(rc));
+    }
+  }
+};
+
+std::unique_ptr<DDCA_Display_Identifier, DisplayIdDeleter> display_id_from_busno(int bus_no) {
+  std::unique_ptr<DDCA_Display_Identifier, DisplayIdDeleter> display_id(new DDCA_Display_Identifier);
+  const DDCA_Status rc = ddca_create_busno_display_identifier(bus_no, display_id.get());
+  if (rc != 0) {
+    spdlog::error("ddcutil: Failed to create bus number display id: {}, {}", ddca_rc_name(rc), ddca_rc_desc(rc));
+    return {};
+  }
+  return display_id;
+}
+
+struct DisplayHandleCloser {
+  void operator()(DDCA_Display_Handle* display_handle) {
+    const DDCA_Status rc = ddca_close_display(*display_handle);
+    if (rc != 0) {
+      spdlog::error("ddcutil: Failed to close display handle: {}, {}", ddca_rc_name(rc), ddca_rc_desc(rc));
+    }
+  }
+};
+
+std::unique_ptr<DDCA_Display_Handle, DisplayHandleCloser> open_display(const DDCA_Display_Ref& display_ref) {
+  std::unique_ptr<DDCA_Display_Handle, DisplayHandleCloser> display_handle(new DDCA_Display_Handle);
+  const DDCA_Status rc = ddca_open_display2(display_ref, false, display_handle.get());
+  if (rc != 0) {
+    spdlog::error("ddcutil: Failed to open display handle: {}, {}", ddca_rc_name(rc), ddca_rc_desc(rc));
+    return {};
+  }
+  return display_handle;
+}
+
+}
+
+waybar::modules::DdcUtil::DdcUtil(const std::string& id, const Bar& bar,
+                                              const Json::Value& config)
+    : ALabel(config, "ddcutil", id, "{status}", 5),
+      bar_(bar),
+      i2c_bus_(config_["bus"].isUInt() ? config_["bus"].asUInt() : -1),
+      input_name_(parse_input_names(config)),
+      primary_input_(lookup_input(config_["primary-input"], input_name_)),
+      secondary_input_(lookup_input(config_["secondary-input"], input_name_)),
+      curr_input_(0), status_("starting") {
+  if (i2c_bus_ < 0) {
+    throw std::runtime_error("Specify the I2C bus");
+  }
+  if (input_name_.empty()) {
+    throw std::runtime_error("Specify input names");
+  }
+  // Report DDC/CI errors to stderr.
+  ddca_init("--ddc", DDCA_SYSLOG_ERROR, DDCA_INIT_OPTIONS_DISABLE_CONFIG_FILE);
+  event_box_.add_events(Gdk::BUTTON_PRESS_MASK);
+  event_box_.signal_button_press_event().connect(sigc::mem_fun(*this, &DdcUtil::handleToggle));
+  worker();
+}
+
+waybar::modules::DdcUtil::~DdcUtil() {
+  // TODO if needed
+}
+
+std::string waybar::modules::DdcUtil::input_source_name(uint8_t input) const {
+  const auto it = input_name_.find(input);
+  if (it == input_name_.end()) return "???";
+  return it->second;
+}
+
+uint8_t waybar::modules::DdcUtil::get_input_source() const {
+  ddca_enable_verify(true);
+  const uint8_t failed = UINT8_MAX;
+
+  const auto display_id = display_id_from_busno(i2c_bus_);
+  if (!display_id) return failed;
+  // Display refs are pre-allocated and don't need to be freed.
+  DDCA_Display_Ref display_ref;
+  DDCA_Status rc = ddca_get_display_ref(*display_id, &display_ref);
+  if (rc != 0) {
+    spdlog::error("ddcutil: Failed to get display ref: {}, {}", ddca_rc_name(rc), ddca_rc_desc(rc));
+    return failed;
+  }
+  const auto display_handle = open_display(display_ref);
+  if (!display_handle) return failed;
+  DDCA_Vcp_Feature_Code input_source(0x60);
+  DDCA_Non_Table_Vcp_Value value;
+  rc = ddca_get_non_table_vcp_value(*display_handle, input_source, &value);
+  if (rc != 0) {
+    spdlog::error("ddcutil: Failed to get input source: {}, {}", ddca_rc_name(rc), ddca_rc_desc(rc));
+    return failed;
+  }
+  return value.sh << 8 | value.sl;
+}
+
+uint8_t waybar::modules::DdcUtil::set_input_source(uint8_t target_input) const {
+  ddca_enable_verify(true);
+  const uint8_t failed = UINT8_MAX;
+
+  const auto display_id = display_id_from_busno(i2c_bus_);
+  if (!display_id) return failed;
+  // Display refs are pre-allocated and don't need to be freed.
+  DDCA_Display_Ref display_ref;
+  DDCA_Status rc = ddca_get_display_ref(*display_id, &display_ref);
+  if (rc != 0) {
+    spdlog::error("ddcutil: Failed to get display ref: {}, {}", ddca_rc_name(rc), ddca_rc_desc(rc));
+    return failed;
+  }
+  const auto display_handle = open_display(display_ref);
+  if (!display_handle) return failed;
+  DDCA_Vcp_Feature_Code input_source(0x60);
+  rc = ddca_set_non_table_vcp_value(*display_handle, input_source, 0, target_input);
+  if (rc != 0) {
+    spdlog::error("ddcutil: Failed to set input source: {}, {}", ddca_rc_name(rc), ddca_rc_desc(rc));
+    return failed;
+  }
+  // Since verify is on, DDC library verified switching worked.
+  return target_input;
+}
+
+std::string waybar::modules::DdcUtil::source_to_class(const uint8_t input) const {
+  if (input == primary_input_) return "primary";
+  else if (input == secondary_input_) return "secondary";
+  else return "error";
+}
+
+void waybar::modules::DdcUtil::worker() {
+  thread_ = [this] {
+    const std::string prev_class = source_to_class(curr_input_);
+    {
+      std::lock_guard<std::mutex> guard(ddc_mutex_);
+      curr_input_ = get_input_source();
+      status_ = input_source_name(curr_input_);
+    }
+    const std::string curr_class = source_to_class(curr_input_);
+    if (prev_class != curr_class) {
+      label_.get_style_context()->remove_class(prev_class);
+      label_.get_style_context()->add_class(curr_class);
+    }
+
+    dp.emit();
+    thread_.sleep_for(interval_);
+  };
+}
+
+auto waybar::modules::DdcUtil::update() -> void {
+  label_.set_markup(fmt::format(fmt::runtime(format_), fmt::arg("status", status_)));
+  if (tooltipEnabled()) {
+    label_.set_tooltip_text(status_);
+  }
+}
+
+bool waybar::modules::DdcUtil::handleToggle(GdkEventButton* const& e) {
+  if (e->button == 1) {  // left click
+    std::lock_guard<std::mutex> guard(ddc_mutex_);
+
+    // Only works to switch an input to itself???
+    uint8_t target_input;
+    if (curr_input_ == primary_input_) target_input = primary_input_;
+    else if (curr_input_ == secondary_input_) target_input = secondary_input_;
+    else {
+      spdlog::error("ddcutil: Unknown current input: {}", status_);
+      ALabel::handleToggle(e);
+      return true;
+    }
+
+    const uint8_t prev_input = curr_input_;
+    curr_input_ = set_input_source(target_input);
+    const std::string input_source = input_source_name(curr_input_);
+    if (input_source != "???") {
+      const std::string prev_class = source_to_class(prev_input);
+      status_ = input_source;
+      const std::string curr_class = source_to_class(curr_input_);
+      if (prev_class != curr_class) {
+        label_.get_style_context()->remove_class(prev_class);
+        label_.get_style_context()->add_class(curr_class);
+      }
+    }
+  }
+  ALabel::handleToggle(e);
+  return true;
+}
